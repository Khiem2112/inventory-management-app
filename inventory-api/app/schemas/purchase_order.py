from datetime import datetime
from decimal import Decimal
from typing import Optional

from pydantic import BaseModel, ConfigDict, Field

from app.schemas.pagination import PaginationMetaData

class PurchaseOrderBase(BaseModel):
    status: str = Field(..., validation_alias="Status")
    supplier_id: int = Field(..., validation_alias="SupplierId")
    purchase_plan_id: Optional[int] = Field(default=None, validation_alias="PurchasePlanId")
    create_user_id: int = Field(..., validation_alias="CreateUserId")
    total_price: Optional[Decimal] = Field(default=None, validation_alias="TotalPrice")
    
    # Pydantic V2 Config to allow population by field name or alias
    model_config = ConfigDict(populate_by_name=True)

# Create Schema: Fields required to create a new entry
class PurchaseOrderCreate(PurchaseOrderBase):
    # CreateDate might be passed in, or generated by DB. 
    # If passed by client:
    create_date: Optional[datetime] = Field(default=None, validation_alias="CreateDate")

# Read Schema: The full representation including ID and DB-generated fields
class PurchaseOrderRead(PurchaseOrderBase):
    purchase_order_id: int = Field(..., validation_alias="PurchaseOrderId")
    create_date: Optional[datetime] = Field(..., validation_alias="CreateDate")

    # This config is CRITICAL for SQLAlchemy integration
    model_config = ConfigDict(from_attributes=True, populate_by_name=True)

class PurchaseOrderPublic(PurchaseOrderBase):
    supplier_name:str = Field(..., validation_alias='SupplierName')
    model_config = ConfigDict(populate_by_name=True, extra='ignore')
    create_user_name: str = Field(..., validation_alias='CreateUserName')

class PurchaseOrderResponse(PaginationMetaData):
    items: list[PurchaseOrderPublic]